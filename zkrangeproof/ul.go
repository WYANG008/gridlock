// Modification from the package https://github.com/ing-bank/zkrangeproof/

/*
This file contains the implementation of the ZKRP scheme proposed in the paper:
Efficient Protocols for Set Membership and Range Proofs
Jan Camenisch, Rafik Chaabouni, abhi shelat
Asiacrypt 2008
*/

package zkrangeproof

import (
	"bytes"
	"crypto/rand"
	"encoding/binary"
	"errors"
	"math/big"
	"strconv"

	"github.com/blockchain-research/gridlock/crypto/bn256"
)

/*
paramsUL contains elements generated by the verifier, which are necessary for the prover.
This must be computed in a trusted setup.
*/
type paramsUL struct {
	signatures map[string]*bn256.G2
	H          *bn256.G2
	// TODO:must protect the private key
	kp keypair
	// u determines the amount of signatures we need in the public params.
	// Each signature can be compressed to just 1 field element of 256 bits.
	// Then the parameters have minimum size equal to 256*u bits.
	// l determines how many pairings we need to compute, then in order to improve
	// verifier`s performance we want to minize it.
	// Namely, we have 2*l pairings for the prover and 3*l for the verifier.
	u, l int64
}

/*
ParamsULVerifier contains the parameters required for verification of zkrp
*/
type ParamsULVerifier struct {
	H    *bn256.G2
	pubk *bn256.G1
	u, l int64
}

/*
proofUL contains the necessary elements for the ZK proof.
*/
type proofUL struct {
	V              []*bn256.G2
	D, C           *bn256.G2
	a              []*bn256.GT
	s, t, zsig, zv []*big.Int
	c, m, zr       *big.Int
}

/*
ProofULVerifier contains the public output which will be used for verification
*/
type ProofULVerifier struct {
	V        []*bn256.G2
	D, C     *bn256.G2
	a        []*bn256.GT
	zsig, zv []*big.Int
	c, zr    *big.Int
}

/*
SetupUL generates the signature for the interval [0,u^l).
The value of u should be roughly b/log(b), but we can choose smaller values in
order to get smaller parameters, at the cost of having worse performance.
*/
func SetupUL(u, l int64) (paramsUL, error) {
	var (
		i int64
		p paramsUL
	)
	p.kp, _ = keygen()

	p.signatures = make(map[string]*bn256.G2)
	for i = 0; i < u; i++ {
		sig_i, _ := sign(new(big.Int).SetInt64(i), p.kp.privk)
		p.signatures[strconv.FormatInt(i, 10)] = sig_i
	}
	//TODO: protect the 'master' key
	h := GetBigInt("18560948149108576432482904553159745978835170526553990798435819795989606410925")
	p.H = new(bn256.G2).ScalarBaseMult(h)
	p.u = u
	p.l = l
	return p, nil
}

// GenerateParamsVefifier generates the public output for verification later
func GenerateParamsVefifier(p *paramsUL) ParamsULVerifier {
	return ParamsULVerifier{
		H:    p.H,
		u:    p.u,
		l:    p.l,
		pubk: p.kp.pubk,
	}
}

/*
ProveUL method is used to produce the ZKRP proof that secret x belongs to the interval [0,U^L].
*/
func ProveUL(x, r *big.Int, cm *bn256.G2, p paramsUL) (proofUL, error) {
	var (
		i         int64
		v         []*big.Int
		proof_out proofUL
	)
	decx, _ := Decompose(x, p.u, p.l)

	// Initialize variables
	v = make([]*big.Int, p.l, p.l)
	proof_out.V = make([]*bn256.G2, p.l, p.l)
	proof_out.a = make([]*bn256.GT, p.l, p.l)
	proof_out.s = make([]*big.Int, p.l, p.l)
	proof_out.t = make([]*big.Int, p.l, p.l)
	proof_out.zsig = make([]*big.Int, p.l, p.l)
	proof_out.zv = make([]*big.Int, p.l, p.l)
	proof_out.D = new(bn256.G2)
	proof_out.D.SetInfinity()
	proof_out.m, _ = rand.Int(rand.Reader, bn256.Order)

	// D = H^m
	D := new(bn256.G2).ScalarMult(p.H, proof_out.m)
	for i = 0; i < p.l; i++ {
		v[i], _ = rand.Int(rand.Reader, bn256.Order)
		A, ok := p.signatures[strconv.FormatInt(decx[i], 10)]
		if ok {
			proof_out.V[i] = new(bn256.G2).ScalarMult(A, v[i])
			proof_out.s[i], _ = rand.Int(rand.Reader, bn256.Order)
			proof_out.t[i], _ = rand.Int(rand.Reader, bn256.Order)
			proof_out.a[i] = bn256.Pair(G1, proof_out.V[i])
			proof_out.a[i].ScalarMult(proof_out.a[i], proof_out.s[i])
			proof_out.a[i].Invert(proof_out.a[i])
			proof_out.a[i].Add(proof_out.a[i], new(bn256.GT).ScalarMult(E, proof_out.t[i]))

			ui := new(big.Int).Exp(new(big.Int).SetInt64(p.u), new(big.Int).SetInt64(i), nil)
			muisi := new(big.Int).Mul(proof_out.s[i], ui)
			muisi = Mod(muisi, bn256.Order)
			aux := new(bn256.G2).ScalarBaseMult(muisi)
			D.Add(D, aux)
		} else {
			return proof_out, errors.New("Could not generate proof. Element does not belong to the interval.")
		}
	}
	proof_out.D.Add(proof_out.D, D)

	// Consider passing C as input,
	// so that it is possible to delegate the commitment computation to an external party.
	proof_out.C = cm //Commit(x, r, p.H)
	// Fiat-Shamir heuristic
	proof_out.c, _ = Hash(proof_out.a, proof_out.D)
	proof_out.c = Mod(proof_out.c, bn256.Order)

	proof_out.zr = Sub(proof_out.m, Multiply(r, proof_out.c))
	proof_out.zr = Mod(proof_out.zr, bn256.Order)
	for i = 0; i < p.l; i++ {
		proof_out.zsig[i] = Sub(proof_out.s[i], Multiply(new(big.Int).SetInt64(decx[i]), proof_out.c))
		proof_out.zsig[i] = Mod(proof_out.zsig[i], bn256.Order)
		proof_out.zv[i] = Sub(proof_out.t[i], Multiply(v[i], proof_out.c))
		proof_out.zv[i] = Mod(proof_out.zv[i], bn256.Order)
	}
	return proof_out, nil
}

// GenerateProofOut generates the public output for verification later
// can minimize the proof size by adjusting u and l, u^l > MAX
//(l+2)|G2| + l|GT| + (2l+2)|BINT|
func GenerateProofVerifier(p proofUL) ProofULVerifier {
	return ProofULVerifier{
		V:    p.V,
		D:    p.D,
		C:    p.C,
		a:    p.a,
		zsig: p.zsig,
		zv:   p.zv,
		c:    p.c,
		zr:   p.zr,
	}
}

/*
VerifyUL is used to validate the ZKRP proof. It returns true iff the proof is valid.
*/
func VerifyUL(proof_out *ProofULVerifier, p ParamsULVerifier) (bool, error) {
	var (
		i      int64
		D      *bn256.G2
		r1, r2 bool
		p1, p2 *bn256.GT
	)
	// D == C^c.h^ zr.g^zsig ?
	D = new(bn256.G2).ScalarMult(proof_out.C, proof_out.c)
	D.Add(D, new(bn256.G2).ScalarMult(p.H, proof_out.zr))
	for i = 0; i < p.l; i++ {
		ui := new(big.Int).Exp(new(big.Int).SetInt64(p.u), new(big.Int).SetInt64(i), nil)
		muizsigi := new(big.Int).Mul(proof_out.zsig[i], ui)
		muizsigi = Mod(muizsigi, bn256.Order)
		aux := new(bn256.G2).ScalarBaseMult(muizsigi)
		D.Add(D, aux)
	}

	DBytes := D.Marshal()
	pDBytes := proof_out.D.Marshal()
	r1 = bytes.Equal(DBytes, pDBytes)

	r2 = true
	for i = 0; i < p.l; i++ {
		// a == [e(V,y)^c].[e(V,g)^-zsig].[e(g,g)^zv]
		p1 = bn256.Pair(p.pubk, proof_out.V[i])
		p1.ScalarMult(p1, proof_out.c)
		p2 = bn256.Pair(G1, proof_out.V[i])
		p2.ScalarMult(p2, proof_out.zsig[i])
		p2.Invert(p2)
		p1.Add(p1, p2)
		p1.Add(p1, new(bn256.GT).ScalarMult(E, proof_out.zv[i]))

		pBytes := p1.Marshal()
		aBytes := proof_out.a[i].Marshal()
		r2 = r2 && bytes.Equal(pBytes, aBytes)
	}
	return r1 && r2, nil
}

/*
Marshal is for marshaling the ParamsULVerifier into []byte
*/
func (p *ParamsULVerifier) Marshal() []byte {
	const bLInt64 int = binary.MaxVarintLen64
	var ret []byte
	//processing H
	bH := p.H.Marshal()
	ret = append(ret, bH...)

	//processing pubk
	bpubk := p.pubk.Marshal()
	ret = append(ret, bpubk...)

	//processing u
	bu := make([]byte, bLInt64, bLInt64)
	binary.PutVarint(bu, p.u)
	ret = append(ret, bu...)

	//processing l
	bl := make([]byte, bLInt64, bLInt64)
	binary.PutVarint(bl, p.l)
	ret = append(ret, bl...)

	return ret
}

/*
UnMarshal is for converting []byte back into ParamsULVerifier
*/
func (p *ParamsULVerifier) Unmarshal(m []byte) *ParamsULVerifier {
	const bLInt64 int64 = binary.MaxVarintLen64
	const bLG2 int64 = 128
	const bLG1 int64 = 64
	//getting H
	p.H, _ = new(bn256.G2).Unmarshal(m[0:bLG2])

	//getting pubk
	p.pubk, _ = new(bn256.G1).Unmarshal(m[bLG2 : bLG1+bLG2])

	//getting u
	p.u, _ = binary.Varint(m[bLG1+bLG2 : bLG1+bLG2+bLInt64])

	//getting l
	p.l, _ = binary.Varint(m[bLG1+bLG2+bLInt64 : bLG1+bLG2+2*bLInt64])
	return p
}

/*
Marshal is for marshaling the ProofULVerifier into []byte
*/
func (p *ProofULVerifier) Marshal() []byte {
	const bLInt int = 32
	var ret []byte

	//processing V
	for _, element := range p.V {
		bV := element.Marshal()
		ret = append(ret, bV...)
	}

	//processing D
	bD := p.D.Marshal()
	ret = append(ret, bD...)

	//processing C
	bC := p.C.Marshal()
	ret = append(ret, bC...)

	//processing a
	for _, element := range p.a {
		ba := element.Marshal()
		ret = append(ret, ba...)
	}

	/* 	//processing s
	   	for _, element := range p.s {
	   		bs := make([]byte, bLInt, bLInt)
	   		b := element.Bytes()
	   		copy(bs[bLInt-len(b):], b)
	   		ret = append(ret, bs...)
	   	}

	   	//processing t
	   	for _, element := range p.t {
	   		bt := make([]byte, bLInt, bLInt)
	   		b := element.Bytes()
	   		copy(bt[bLInt-len(b):], b)
	   		ret = append(ret, bt...)
	   	} */

	//processing zsig
	for _, element := range p.zsig {
		bzsig := make([]byte, bLInt, bLInt)
		b := element.Bytes()
		copy(bzsig[bLInt-len(b):], b)
		ret = append(ret, bzsig...)
	}

	//processing zv
	for _, element := range p.zv {
		bzv := make([]byte, bLInt, bLInt)
		b := element.Bytes()
		copy(bzv[bLInt-len(b):], b)
		ret = append(ret, bzv...)
	}

	//processing c, m, zr
	bc := make([]byte, bLInt, bLInt)
	b := p.c.Bytes()
	copy(bc[bLInt-len(b):], b)
	ret = append(ret, bc...)

	/* 	bm := make([]byte, bLInt, bLInt)
	   	b = p.m.Bytes()
	   	copy(bm[bLInt-len(b):], b)
	   	ret = append(ret, bm...) */

	bzr := make([]byte, bLInt, bLInt)
	b = p.zr.Bytes()
	copy(bzr[bLInt-len(b):], b)
	ret = append(ret, bzr...)

	return ret
}

/*
UnMarshal is for converting []byte back into proofUL
*/
func (p *ProofULVerifier) Unmarshal(m []byte, L int64) *ProofULVerifier {
	const bLG2 int64 = 128
	const bLGT int64 = 384
	const bLInt int64 = 32
	var i int64

	//getting V
	for i = 0; i < L; i++ {
		v, _ := new(bn256.G2).Unmarshal(m[i*bLG2 : (i+1)*bLG2])
		p.V = append(p.V, v)
	}

	//getting D
	p.D, _ = new(bn256.G2).Unmarshal(m[L*bLG2 : (L+1)*bLG2])

	//getting C
	p.C, _ = new(bn256.G2).Unmarshal(m[(L+1)*bLG2 : (L+2)*bLG2])

	//getting a
	index := (L + 2) * bLG2
	for i = 0; i < L; i++ {
		a, _ := new(bn256.GT).Unmarshal(m[index+i*bLGT : index+(i+1)*bLGT])
		p.a = append(p.a, a)
	}

	//get zsig
	index = (L+2)*bLG2 + L*bLGT
	for i = 0; i < L; i++ {
		zsig := new(big.Int).SetBytes(m[index+i*bLInt : index+(i+1)*bLInt])
		p.zsig = append(p.zsig, zsig)
	}

	//get zv
	index = (L+2)*bLG2 + L*bLGT + L*bLInt
	for i = 0; i < L; i++ {
		zv := new(big.Int).SetBytes(m[index+i*bLInt : index+(i+1)*bLInt])
		p.zv = append(p.zv, zv)
	}

	//get c, m, zr
	index = (L+2)*bLG2 + L*bLGT + (L*2)*bLInt
	p.c = new(big.Int).SetBytes(m[index : index+bLInt])

	index = (L+2)*bLG2 + L*bLGT + (L*2+1)*bLInt
	p.zr = new(big.Int).SetBytes(m[index : index+bLInt])

	return p
}
